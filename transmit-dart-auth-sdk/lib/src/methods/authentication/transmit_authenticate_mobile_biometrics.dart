import 'dart:convert';
import 'package:ds_standard_features/ds_standard_features.dart' as http;

/// A service for authenticating users via native mobile biometrics using Transmit Security's API.
///
/// This class handles biometric authentication by verifying cryptographic signatures
/// generated by the device's secure enclave or trusted execution environment.
///
/// ## Security Considerations
/// - Requires valid API credentials
/// - Verifies cryptographic signatures server-side
/// - Implements challenge-response protocol to prevent replay attacks
/// - Should be used with HTTPS only
/// - Biometric data never leaves the device
///
/// ## Authentication Flow
/// 1. Client requests a challenge from server
/// 2. Device signs challenge using biometric-protected key
/// 3. Client submits signed challenge for verification
/// 4. Server validates signature and issues tokens
///
/// ## Example Usage
/// ```dart
/// final biometricAuth = AortemTransmitAuthenticateNativeMobileBiometrics(
///   apiKey: 'your-api-key',
///   baseUrl: 'https://api.transmitsecurity.com',
/// );
///
/// try {
///   final tokens = await biometricAuth.authenticateNativeMobileBiometrics(
///     userId: 'user123',
///     signature: 'generated_signature',
///     challenge: 'server_challenge',
///     keyId: 'device_key_id',
///   );
///   print('Biometric authentication successful');
/// } catch (e) {
///   print('Biometric authentication failed: $e');
/// }
/// ```
class AortemTransmitAuthenticateNativeMobileBiometrics {
  /// The API key used for service authentication
  final String apiKey;

  /// The base URL for the biometric authentication API endpoint
  final String baseUrl;

  /// Creates a biometric authentication service instance
  ///
  /// [apiKey]: Required API key for service authentication
  /// [baseUrl]: Required base URL for the API endpoint
  AortemTransmitAuthenticateNativeMobileBiometrics({
    required this.apiKey,
    required this.baseUrl,
  });

  /// Authenticates a user using native mobile biometrics
  ///
  /// Parameters:
  /// [userId]: Unique identifier of the user (required)
  /// [signature]: Cryptographic signature generated by device (required)
  /// [challenge]: Server-generated challenge string (required)
  /// [keyId]: Identifier of the biometric-protected key (required)
  /// [resource]: Optional audience for the tokens
  /// [claims]: Additional claims to include in tokens
  /// [orgId]: Organization identifier for multi-tenant systems
  /// [clientAttributes]: Client-specific metadata
  /// [sessionId]: Existing session identifier to associate with
  ///
  /// Returns:
  /// A [Future] that resolves to a Map containing:
  /// - `access_token`: Short-lived JWT access token
  /// - `id_token`: JWT containing user identity claims
  /// - `refresh_token`: Long-lived refresh token
  /// - `token_type`: Typically "Bearer"
  /// - `expires_in`: Access token validity in seconds
  /// - `session_id`: Session identifier
  /// - Additional service-specific metadata
  ///
  /// Throws:
  /// - [ArgumentError] if any required parameter is empty
  /// - [Exception] with detailed error message if authentication fails
  Future<Map<String, dynamic>> authenticateNativeMobileBiometrics({
    required String userId,
    required String signature,
    required String challenge,
    required String keyId,
    String? resource,
    Map<String, dynamic>? claims,
    String? orgId,
    Map<String, dynamic>? clientAttributes,
    String? sessionId,
  }) async {
    if (userId.isEmpty ||
        signature.isEmpty ||
        challenge.isEmpty ||
        keyId.isEmpty) {
      throw ArgumentError(
        'userId, signature, challenge, and keyId must not be empty',
      );
    }

    try {
      final url = Uri.parse('$baseUrl/v1/auth/biometrics/native/authenticate');

      final headers = {
        'Authorization': 'Bearer $apiKey',
        'Content-Type': 'application/json',
        'X-Request-ID': DateTime.now().millisecondsSinceEpoch.toString(),
      };

      final body = <String, dynamic>{
        'user_id': userId,
        'signature': signature,
        'challenge': challenge,
        'key_id': keyId,
        if (resource != null) 'resource': resource,
        if (claims != null) 'claims': claims,
        if (orgId != null) 'org_id': orgId,
        if (clientAttributes != null) 'client_attributes': clientAttributes,
        if (sessionId != null) 'session_id': sessionId,
      };

      final response = await http.post(
        url,
        headers: headers,
        body: jsonEncode(body),
      );

      if (response.statusCode == 200) {
        return jsonDecode(response.body) as Map<String, dynamic>;
      } else {
        throw _createBiometricException(response);
      }
    } on FormatException catch (e) {
      throw Exception('Failed to parse biometric response: ${e.message}');
    } on http.ClientException catch (e) {
      throw Exception(
        'Network error during biometric authentication: ${e.message}',
      );
    }
  }

  /// Mock implementation for testing biometric authentication
  ///
  /// Simulates successful authentication without API calls.
  Future<Map<String, dynamic>> mockAuthenticateNativeMobileBiometrics({
    required String userId,
    required String signature,
    required String challenge,
    required String keyId,
  }) async {
    await Future.delayed(
      const Duration(milliseconds: 200),
    ); // Simulate network delay

    return {
      'access_token': 'mock_biometric_token_${userId.hashCode}',
      'id_token': 'mock_id_token_${DateTime.now().millisecondsSinceEpoch}',
      'refresh_token': 'mock_refresh_token_${keyId.hashCode}',
      'token_type': 'Bearer',
      'expires_in': 3600,
      'session_id': 'mock_session_${userId.hashCode}',
      'biometric_verified': true,
      'device_id': 'mock_device_${keyId.hashCode}',
    };
  }

  /// Creates a detailed exception from biometric authentication failures
  Exception _createBiometricException(http.Response response) {
    try {
      final error = jsonDecode(response.body) as Map<String, dynamic>;
      final statusCode = response.statusCode;
      final errorCode = error['error'] ?? 'biometric_verification_failed';
      final description =
          error['error_description'] ?? 'No description provided';

      switch (statusCode) {
        case 400:
          return Exception(
            'Invalid biometric data: $description (code: $errorCode)',
          );
        case 401:
          return Exception(
            'Biometric verification failed: $description (code: $errorCode)',
          );
        case 403:
          return Exception(
            'Biometric access denied: $description (code: $errorCode)',
          );
        case 409:
          return Exception(
            'Biometric key mismatch: $description (code: $errorCode)',
          );
        default:
          return Exception(
            'Biometric error ($statusCode): $description (code: $errorCode)',
          );
      }
    } on FormatException {
      return Exception(
        'Biometric authentication failed (${response.statusCode}): ${response.body}',
      );
    }
  }
}
